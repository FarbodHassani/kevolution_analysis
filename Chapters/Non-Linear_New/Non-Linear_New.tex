\documentclass[a4paper,12pt]{article}
%% My standard included packages
%\pdfoutput=1 % if your are submitting a pdflatex (i.e. if you have
%             % images in pdf, png or jpg format)
%\usepackage{jcappub} % for details on the use of the package, please
%                     % see the JCAP-author-manual
%\usepackage[T1]{fontenc} % if needed

\usepackage{setspace}           % Allows easy changes to line spacing 
\usepackage{graphicx}           % Allows including of graphics files
\usepackage{amsmath}            % Additional math capabilities
\usepackage{marginnote}         % Used with todonotes package
\usepackage{datetime}           % Allows formatting of date and time
\newcommand {\be}{\begin{equation}}
\newcommand {\ee}{\end{equation}}

\usepackage{empheq}
\usepackage{cancel}
\usepackage{etoolbox}


\usepackage{enumitem} 
\usepackage{color}
%Mathematica colors
\definecolor{identifiercolor}{rgb}{.4,.6,.56}
\definecolor{stringcolor}{gray}{0.5}
\definecolor{inactivecolor}{rgb}{0.15,0.15,0.5}
\usepackage{listings}
%Mathematica
\usepackage{listings}
\lstset{basicstyle={\footnotesize\def\fvm@Scale{.85}\fontfamily{fvm}\selectfont},
  breaklines=true,
  escapeinside={\%*}{*)},
  keywordstyle={\bfseries\color{inactivecolor}},
  stringstyle={\bfseries\color{stringcolor}},
  identifierstyle={\bfseries\color{identifiercolor}},
  language=Mathematica,
  otherkeywords={DiscretizeRegion},
  showstringspaces=false}
\renewcommand{\lstlistingname}{Listing}




\usepackage{amsmath}
\usepackage{graphicx}% Use pdf, png, jpg, or epså¤ with pdflatex; use eps in DVI mode
\usepackage{caption}
\usepackage{subcaption}
          % List formatting commands
\setlist{noitemsep}             % Remove space between list items 
%\usepackage{subfigure}          % Create numbered and captioned subfigures
\usepackage{rotating}           % Create landscape tables and figures
\usepackage[dvipsnames]{xcolor} % Refer to colors by name
\usepackage[colorlinks=true,urlcolor=blue,linkcolor=Orange,citecolor=RedViolet]{hyperref}           % URLS and hyperlinks
%\usepackage{hyperref}           % URLS and hyperlinks
\usepackage{float}              % Activate [H] option to place figure HERE
\usepackage[numbers]{natbib}
\usepackage{versionPO}          % Include text conditionally
\usepackage{caption}
%\usepackage[utf8]{inputenc}
%\usepackage[nottoc]{tocbibind}
\lstset{basicstyle=\ttfamily,
  showstringspaces=false,
  commentstyle=\color{red},
  keywordstyle=\color{blue}
}
% These next lines allow including or excluding different versions of text
% using versionPO.sty
\includeversion{notes}		% Include notes?
%\excludeversion{notes}
\excludeversion{comment}
\includeversion{links}          % Turn hyperlinks on?
\excludeversion{submit}		% Format for conference submission?
\includeversion{toc}		% Include table of contents?
%\graphicspath{{./Results1-Perihelionadvance}}

% Turn off hyperlinking if links is excluded
\iflinks{}{\hypersetup{draft=true}}

% Notes options
\ifnotes{%
\usepackage[margin=1in,paperwidth=10in,right=2.5in]{geometry}%
\usepackage[textwidth=1.4in,shadow,colorinlistoftodos]{todonotes}%
}{%
\usepackage[margin=1in]{geometry}%
\usepackage[disable]{todonotes}%
}

% Allow todonotes inside footnotes without blowing up LaTeX
% Next command works but now notes can overlap. Instead, we'll define 
% a special footnote note command that performs this redefinition.
%\renewcommand{\marginpar}{\marginnote}%

% Save original definition of \marginpar
\let\oldmarginpar\marginpar
% Workaround for todonotes problem with natbib (To Do list title comes out wrong)
\makeatletter\let\chapter\@undefined\makeatother % Undefine \chapter for todonotes
% Packages included specifically for this document.
\usepackage{texintro}           % Document-specific definitions
\usepackage{tocvsec2}           % More flexible formatting of table of contents
\usepackage{bibentry}           % Print full citation in text
\nobibliography*                                % Allow use of \bibentry command
\usepackage{tikz}             % Already included by todonotes
\usetikzlibrary{matrix}
\usepackage[retainorgcmds]{IEEEtrantools}  % Equation formatting. Option needed to
                                           % allow enumitem to work.

% Workaround for todonotes problem with natbib (To Do list title comes out wrong)
% If you're including tocvsec2, do so before this command.
\makeatletter\let\chapter\@undefined\makeatother % Undefine \chapter for todonotes.

% Number paragraphs and subparagraphs and include them in TOC
%\setcounter{tocdepth}{2}

\usepackage[affil-it]{authblk} 
\usepackage{etoolbox}
\usepackage{titlesec}

\setcounter{secnumdepth}{4}

\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}


\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bean{\begin{eqnarray*}}
\def\eean{\end{eqnarray*}}
\def\cd{\cdot}
\def\vp{\varphi}
\def\l {\langle}
\def\re {\rangle}
\def \dd {\partial}
\def \ra {\rightarrow}
\def \la {\lambda}
\def \La {\Lambda}
\def \De {\Delta}
\def \DH {\Delta_{\rm HI}}
\newcommand{\de}{\delta}
\def \b {\beta}
\def \al {\alpha}
\def \ka {\kappa}
\def \Ga {\Gamma}
\def \ga {\gamma}
\def \si {\sigma}
\def \Si {\Sigma}
\def \ep {\epsilon}
\def \om {\omega}
\def \Om {\Omega}
\def \lap {\triangle}
\def \ep {\epsilon}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Special definitions for this paper
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\MyRed}{\color [rgb]{0.8,0,0}}
\newcommand{\MyGreen}{\color [rgb]{0,0.7,0}}
\newcommand{\MyBlue}{\color [rgb]{0,0,0.8}}
\newcommand{\MyBrown}{\color [rgb]{0.8,0.4,0.1}}
\newcommand{\MyPurple}{\color [rgb]{0.6,0.0,0.6}}
\def\GV#1{{\MyRed [GV: #1]}}
\def\RD#1{{\MyGreen [RD:  {\tt #1}]}} 
\def\RDt#1{{\MyGreen #1}}   
\def\GM#1{{\MyBlue [GM: #1]}}  
\def\GF#1{{\MyPurple [GF: #1]}}    



\newcommand{\ie}{\emph{i. e.}}
\newcommand{\cf}{\emph{cf.}}
\newcommand{\etal}{\emph{et al.}\xspace}
\newcommand{\eg}{\emph{e. g.}}

\newcommand{\Scal}{\mathcal S}
\newcommand{\DD}{\mathcal D}
\newcommand{\EE}{\mathcal E}
\newcommand{\MM}{\mathcal M}
\newcommand{\HH}{\mathcal H}

\newcommand{\Real}{\mathbb{R}}
\newcommand{\bn}{\boldsymbol{n}}
\newcommand{\bv}{\boldsymbol{v}}
\newcommand{\bx}{\boldsymbol{x}}
\newcommand{\bnabla}{\boldsymbol{\nabla}}
\newcommand{\bell}{\boldsymbol{\ell}}
\newcommand{\bal}{\boldsymbol{\alpha}}





%\usepackage{lmodern}
%\renewcommand\Authfont{\fontsize{12}{14.4}\selectfont}
%\renewcommand\Affilfont{\fontsize{9}{10.8}\itshape}
%\renewcommand\Authfont{\fontsize{12}{15}\selectfont}
%\renewcommand\Affilfont{\fontsize{9}{11}\itshape}
\definecolor{astral}{RGB}{46,116,181}
%\subsectionfont{\color{astral}}
%\sectionfont{\color{astral}}
%\usdate{17 May}                         % Use usual LaTeX date layout

%\title{\color{BlueViolet}\Huge{On the accuracy of approximated geodesic equations and different potentials with different numerical methods } }
\title{\color{BlueViolet}\Huge{Just part of projects which should be added to the original version}}
%\vskip 2em
\author{Farbod Hassani}
%\thanks{Email:\href{mailto:farbod.hassani@unige.ch}{{farbod.hassani@unige.ch}}}  \thanks{Homepage: \href{http://www.farbod-hassani.com}{farbod-hassani.com}}}
%\affil{D\'epartement de Physique Th\'eorique and Center for Astroparticle Physics, Universit\'e de Gen\'eve,
%24 quai Ansermet, CH-1211 Gen\'eve 4, Switzerland}

%{farbod-hassani.com}} }
%\newcommand*{\TitleFont}{%     \usefont{\encodingdefault}{\rmdefault}{b}'%     \fontsize{18}{16}%    \selectfont}
%\title{\TitleFont Halo finder}
%\author[1]{{Farbod Hassani} \thanks{ \url{farbod.hassani@gmail.com}
%}
%\thanks{farbod-hassani.com}}
%\author[2]{Author E\thanks{E.E@university.edu}}
%\affil[1]{D\'epartement de Physique Th\'eorique and Center for Astroparticle Physics, Universit\'e de Gen\'eve,
%24 quai Ansermet, CH-1211 Gen\'eve 4, Switzerland}
%\emailAdd{farbod.hassani@gmail.com}
%\affil[2]{Department of Mechanical Engineering, \LaTeX\ University}
      %\begin{abstract}
%This is abstract text: This simple document shows very basic features of \LaTeX{}.
%\lstset { %
%    language=C++,
%    %backgroundcolor=\color{black!5}, % set backgroundcolor
%    basicstyle=\footnotesize,% basic font settings
%}
\begin{document}

\section{Non-linear contrubution}
{Martin: We can look at k =10 \\
Just note that, if we dont run the GEvolution from enough large scale, we lose the the long mode modulation and the pertubration on quadratic variables would change like $\chi$ ..,
and on the other hand also we have the large power from non linearities of scalar field  }
Here we write the full equations and try to solve them numerically in Gevolution, and if we got something intreesting or strange we need to solve them in mathematica to see if we did not have make a mistake ! \\ 
     \begin{align} 
 &{ \pi''+\mathcal{H}(1- 3w) \pi' } +3 {  \mathcal{H}}\Big( -c_s^2+ {w} \Big )\Psi - \, {\Psi'}- 3 c_s^2  \,{\Phi'} + {
 \Big( 3\mathcal{H}^2 (c_s^2 -w) + \mathcal{H}' (1-3c_s^2)\Big) \pi }
           \nonumber
   \\
    &
 - c_s^2 {\nabla^2 \pi }
    % Second order terms
     -2 c_s^2  \Phi  {\nabla^2 \pi }  
  %//////////////// 
  +   (1-c_s^2)  \Psi {\nabla^2 \pi}
  %////////////////
  +3 c_s^2 \mathcal{H} (1+w)\pi {\nabla^2 \pi }
      %////////////////
        -   (1-c_s^2)  { (\mathcal{H} \pi+ \pi') } \nabla^2 {\pi }
                                       \nonumber
   \\
    &
        %//////////////// 
             +c_s^2 {\nabla  \Phi . \nabla \pi}
   %//////////////// 
        -(2 c_s^2-1) {\nabla  \Psi . \nabla \pi }  
   %//////////////// 
 +\frac{\mathcal{H}} {2 } \Big(2+3w+c_s^2  \Big){\nabla  \pi . \nabla \pi} 
    %//////////////// 
     -2   (1-c_s^2){\nabla  \pi . {  \nabla {  (\mathcal{H} \pi+ \pi')   }}}     =0
  \end{align} 
\begin{align}
 & T_0^0 (Gev)=  \Omega^0_{kess} a^{-3 w}  \Bigg[1+ \frac{1+w}{c_s^2} \Bigg(- 3 \mathcal{H}c_s^2 \pi- \Psi+   {({\pi'}+ \mathcal{H} \pi) }  -  (1-2 c_s^2 ) 
 \frac{(\vec{\nabla} \pi)^2}{2} \Bigg )      \Bigg ]
\nonumber \\ &
T^{i}_{0}(Gev)= - \Omega^0_{kess} a^{-3 w} (1+w)  \Big[1 - (\frac{1}{c_s^2} -1)  \frac{(\vec{\nabla} \pi)^2}{2}  \Big ] \partial _i \pi 
\nonumber \\ &
T_{j}^{i}(Gev)= w  \, \Omega^0_{kess} a^{-3 w} \Bigg ( 1+  \frac{1+w}{w}\Big [ -3 \mathcal{H} w \pi- \Psi +   {({\pi'}+ \mathcal{H} \pi) }  -  \frac{(\vec{\nabla} \pi)^2}{2}   \Big] \delta_{j}^{i}  + \frac{1+w}{w} \delta^{i k} \partial_k \pi \partial_j \pi  \Bigg) 
\end{align}
we take $\pi$ and $\zeta$ defined as following  as new set of variables,
\be
\zeta \doteq	 -\Psi + \pi' + \mathcal{H} \pi,
\ee
After substitution $\pi' \to \zeta + \Psi - \mathcal{H} \pi$ we get the following expression for stress tensor according to mathematica, which is very clear,
\begin{figure} [H]
 \includegraphics [scale=0.6]{mathematica_stress_001}
 \end{figure}
 So the stress tensor reads,
\begin{align}
 & T_0^0 (Gev)=  \Omega^0_{kess} a^{-3 w}  \Bigg[1+ \frac{1+w}{c_s^2} \Bigg(\zeta - 3 \mathcal{H}c_s^2 \pi -  (1-2 c_s^2 ) 
 \frac{(\vec{\nabla} \pi)^2}{2} \Bigg )      \Bigg ]
\nonumber \\ &
T^{i}_{0}(Gev)= - \Omega^0_{kess} a^{-3 w} (1+w)  \Big[1 - (\frac{1}{c_s^2} -1)  \frac{(\vec{\nabla} \pi)^2}{2}  \Big ] \partial _i \pi 
\nonumber \\ &
T_{j}^{i}(Gev)= w  \, \Omega^0_{kess} a^{-3 w} \Bigg ( 1+  \frac{1+w}{w}\Big [ -3 \mathcal{H} w \pi +\zeta -  \frac{(\vec{\nabla} \pi)^2}{2}   \Big] \delta_{j}^{i}  + \frac{1+w}{w} \delta^{i k} \partial_k \pi \partial_j \pi  \Bigg) 
\end{align}

After substitution in mathematica we get,
  \begin{align} 
 &{ \zeta' - (\mathcal{H} \pi)' +\Psi'+\mathcal{H}(1- 3w) ( \zeta- \mathcal{H} \pi+\Psi) } +3 {  \mathcal{H}}\Big( -c_s^2+ {w} \Big )\Psi - \, {\Psi'}- 3 c_s^2  \,{\Phi'} + {
 \Big( 3\mathcal{H}^2 (c_s^2 -w) + \mathcal{H}' (1-3c_s^2)\Big) \pi }
           \nonumber
   \\
    &
 - c_s^2 {\nabla^2 \pi }
    % Second order terms
     -2 c_s^2  \Phi  {\nabla^2 \pi }  
  %//////////////// 
  +   (1-c_s^2)  \Psi {\nabla^2 \pi}
  %////////////////
  +3 c_s^2 \mathcal{H} (1+w)\pi {\nabla^2 \pi }
      %////////////////
        -   (1-c_s^2)  { (\zeta + \Psi) } \nabla^2 {\pi }
                                       \nonumber
   \\
    &
        %//////////////// 
             +c_s^2 {\nabla  \Phi . \nabla \pi}
   %//////////////// 
        -(2 c_s^2-1) {\nabla  \Psi . \nabla \pi }  
   %//////////////// 
 +\frac{\mathcal{H}} {2 } \Big(2+3w+c_s^2  \Big){\nabla  \pi . \nabla \pi} 
    %//////////////// 
     -2   (1-c_s^2){\nabla  \pi . {  \nabla {  (\zeta + \Psi)   }}}     =0
    % Second order terms==0
  \end{align}
  The linear part simplification gives the same equation we had before and we can rewrite the  equation as following,
    \begin{align} 
 & \zeta' -3w \mathcal{H} \zeta + 3 c_s^2 \Big(  \mathcal{H}^2- \mathcal{H}' \Big) \pi   - 3 c_s^2 \Big ( \,{\Phi'}  +\mathcal{H} \Psi \Big)- c_s^2 {\nabla^2 \pi }
           \nonumber
   \\
    &
    % Second order terms
     -2 c_s^2  \Phi  {\nabla^2 \pi }  
  %//////////////// 
  +   (1-c_s^2)  \Psi {\nabla^2 \pi}
  %////////////////
  +3 c_s^2 \mathcal{H} (1+w)\pi {\nabla^2 \pi }
      %////////////////
        -   (1-c_s^2)  { (\zeta + \Psi) } \nabla^2 {\pi }
                                       \nonumber
   \\
    &
        %//////////////// 
             +c_s^2 {\nabla  \Phi . \nabla \pi}
   %//////////////// 
        -(2 c_s^2-1) {\nabla  \Psi . \nabla \pi }  
   %//////////////// 
 +\frac{\mathcal{H}} {2 } \Big(2+3w+c_s^2  \Big){\nabla  \pi . \nabla \pi} 
    %//////////////// 
     -2   (1-c_s^2){\nabla  \pi . {  \nabla {  (\zeta + \Psi)   }}}     =0
    % Second order terms==0
  \end{align}
  The other equation is like before,
  \be
  \pi' = \zeta + \Psi - \mathcal{H} \pi
  \ee
  We actually did nothing except substituting the $\pi'$ and in non-linear part the substitution is very straightforward. Just note that in Gevolution to compute ${\nabla  \pi . {  \nabla {  (\zeta + \Psi)   }}}$  we use the symmetric derivative as follwoing,
  \be
  {\nabla  \pi . {  \nabla {  (\zeta + \Psi)   }}} = \frac{1}{4dx^2}\sum_i  \Big[{\pi(x_i+1) -\pi(x_i-1) } \Big]  \Big[ \big(\zeta(x_i+1) + \Psi (x_i+1) \big) -\big(\zeta(x_i-1) + \Psi (x_i-1) \big)  \Big]
  \ee
  where "1/4" coefficient appear since we are using symmetric derivative and using points with distance two. "$x_i$" is the lattice coordinate.
  \subsection{Solving the equation by leap-frog method}
  Here we explain how we solve the two equations using leap-frog method,
   \subsubsection{$\pi$ equation}
 for the $\pi$ equation we have,
    \be
      \pi_{n+1}=\pi_{n} + \pi'_{n+\frac{1}{2}} \Delta \tau
    \ee
     \be
  \pi'_{n+\frac{1}{2}}=\zeta_{n+\frac{1}{2}}  -\mathcal{H}_{n+\frac{1}{2}}  \pi_{n+\frac{1}{2}}  +\Psi_{n+\frac{1}{2}} 
      \ee
      According to the definition, since the equation for updating $\pi$ is linear we do not have any trouble with non-linear terms and this part is done like linear equations.\\
      The background part  shoule be updated  before this step to have $a_{kess}$ at (n+1/2) and then having $\mathcal{H}(n+1/2)$. 
      Just note that making $\zeta$ updating at half steps help us because we need all the terms in $\zeta'(n)$ at integer steps. \\
      Moreover we update $\zeta$ first, so we have it in $\zeta_{n+1/2}$.\\
      writing,
%      Since the scalar field Stress energy tensor must be synchronized with particles stress tensor, we need to have all the variables at the same step which is $n$, so we need to write all the terms at step ${n+\frac{1}{2}} $ in terms of the values at step $n$ and $n+1$ as following, of course except $\zeta$ which we have it at $n+1/2$. The easiest model to calculate $F_{{n+\frac{1}{2}} }$ is by taking average of the next and last step, so
     \be
     \pi_{n+\frac{1}{2}} = \frac{ \pi_{n+1} + \pi_{n} }{2 }
     \ee
     and the same for all the other variables at step ${n+\frac{1}{2}}$. 
     
     For $\pi$ we have,
     \be
      \pi_{n+1}= \pi_{n} + \Delta  \tau \Big [  \zeta_{n+\frac{1}{2}}   -\mathcal{H}_{n+\frac{1}{2}}  ( \frac{ \pi_{n+1} + \pi_{n} }{2 })  +\Psi_{n+\frac{1}{2}} \Big ]
     \ee
         \be
      \pi_{n+1}=  \frac{1}{1+ \mathcal{H}_{n+\frac{1}{2}} \Delta \tau/2}\Bigg[ \pi_{n} + \Delta \tau \Big [  \zeta_{n+\frac{1}{2}}   -\mathcal{H}_{n+\frac{1}{2}}   \frac{  \pi_{n} }{2 } +\Psi_{n+\frac{1}{2}}  \Big ] \Bigg]
     \ee
   As it is clear from the formula we don't have access to the $\Psi_{n+\frac{1}{2}} $ , so we use the extrapolation  to have them in next half steps,
   \begin{align}
      \Psi_{n+\frac{1}{2}} = \Psi_{n} + \Psi'_{n} \frac{d \tau}{2} 
   \end{align} 

   Moreover to have $\Psi'_{n}$ we  use the following formula by saving $\Psi$ at two different steps!
   \be
   \Psi'_{n} = \frac{\Psi_{n} - \Psi_{n-1} }{d \tau}
   \ee
\subsubsection{$\zeta$ equation}
We chose to update $\zeta$ at half steps since then we need its derivative at integer steps and make the computation simplified. Moreover first $\zeta$ is updated to have it at step $n+1/2$, then $\pi$ is updated to get the values at $n+1$, just note that although we need $\zeta$ at integer steps to be synchronized with particles and $\pi$, but since getting $\zeta_{n+1}$ makes the ways very complicated we just use the following formula to obtain it, if it is really necessary! Since we guess that putting $\zeta_{n+1/2}$ as $\zeta_{n+1}$ in stress tensor is enough.
  \be
  \zeta_{n+1}=\zeta_{n+\frac{1}{2}} + \zeta'_{n} \Delta \tau/2 \label{eqzeta}
  \ee
%  Just note that in the last step $\pi$ is updated, so at the current state we have $\zeta_{n+1/2}$ , $\pi_{n+1}$ and $\zeta_{n}$ .
%   $\zeta_{n+1/2}$ which is obtained in the previous loop, $\zeta_{n}$ which in the previous loop was the average of $\zeta_{n-1/2}$ and $\zeta_{n+1/2}$, and $\pi_n$ was recently updated. \\
   $ \zeta'_{n}$ in the equation \ref{eqzeta} reads from the differential equation as following,
  \begin{align}
  \zeta'_{n} &= 3 \mathcal{H}_{n}(w \zeta_{n} +c_s^2 \Psi_{n}) -c_s^2(   3 \mathcal{H}^2_{n} 
  - 3 \mathcal{H}' _{n}) \pi_{n}+ 3 c_s^2 \Phi'_{n}  +c_s^2 \nabla^2 \pi_{n} \\ \nonumber &
   % Second order terms
     +2 c_s^2  \Phi_{n}  {\nabla^2 \pi_{n} }  
  %//////////////// 
  -   (1-c_s^2)  \Psi_{n} {\nabla^2 \pi_{n}}
  %////////////////
  -3 c_s^2 \mathcal{H}_{n} (1+w)\pi_{n} {\nabla^2 \pi_{n} }
      %////////////////
        +  (1-c_s^2)  { (\zeta_{n} + \Psi_{n}) } \nabla^2 {\pi_{n} }
                                       \nonumber
   \\
    &
    %//////////////// 
             -c_s^2 {\nabla  \Phi_{n} . \nabla \pi_{n}}
   %//////////////// 
        +(2 c_s^2-1) {\nabla  \Psi_{n} . \nabla \pi_{n} }  
   %//////////////// 
 -\frac{\mathcal{H}_{n}} {2 } \Big(2+3w+c_s^2  \Big){\nabla  \pi_{n} . \nabla \pi_{n}} 
    %//////////////// 
     +2   (1-c_s^2){\nabla  \pi_{n} . {  \nabla {  (\zeta_{n} + \Psi_{n})   }}}   
    \end{align}
    Since we need $ \nabla   (\zeta_{n} + \Psi_{n})  $ we write $\zeta_{n}  = \frac{\zeta_{n+1/2} + \zeta_{n-1/2}}{2} $

      \begin{align}
  \zeta_{n+\frac{1}{2}} =&\zeta_{n-\frac{1}{2}} +  \Delta \tau \Bigg [3 \mathcal{H}_{n}(w\frac{\zeta_{n+\frac{1}{2}} + \zeta_{n-\frac{1}{2}} }{2} +c_s^2 \Psi_{n}) -c_s^2(   3 \mathcal{H}^2_{n} 
  - 3 \mathcal{H}' _{n}) \pi_{n}+ 3 c_s^2 \Phi'_{n}  +c_s^2 \nabla^2 \pi_{n} 
    \nonumber \\ &
  % Second order terms
     +2 c_s^2  \Phi_{n}  {\nabla^2 \pi_{n} }  
  %//////////////// 
  -   (1-c_s^2)  \Psi_{n} {\nabla^2 \pi_{n}}
  %////////////////
  -3 c_s^2 \mathcal{H}_{n} (1+w)\pi_{n} {\nabla^2 \pi_{n} }
      %////////////////
        +  (1-c_s^2)  { \Big( \frac{\zeta_{n+1/2} + \zeta_{n-1/2} }{2}+ \Psi_{n} \Big) } \nabla^2 {\pi_{n} }
                       \nonumber
   \\
    &
    %//////////////// 
             -c_s^2 {\nabla  \Phi_{n} . \nabla \pi_{n}}
   %//////////////// 
        +(2 c_s^2-1) {\nabla  \Psi_{n} . \nabla \pi_{n} }  
   %//////////////// 
 -\frac{\mathcal{H}_{n}} {2 } \Big(2+3w+c_s^2  \Big){\nabla  \pi_{n} . \nabla \pi_{n}} 
    %//////////////// 
    \nonumber \\ &
     +2   (1-c_s^2){\nabla  \pi_{n} . {  \nabla {  \Big(\ \frac{\zeta_{n+1/2} + \zeta_{n-1/2} }{2}+ \Psi_{n} \Big)   }}}    \Bigg]
    \end{align}
As one can see the term $ \nabla   \Big( \frac{\zeta_{n+1/2} + \zeta_{n-1/2} }{2}+ \Psi_{n} \Big)  $ is somehow problematic, since we cannot factorize the $\zeta_{n+1/2}$ and $\zeta_{n-1/2}$ simply or its better to have a field $\zeta_{int}$ which lives in the integer steps and in principle we $\zeta_{n}$ and we can use predictor-corrector method to improve this value. Here we use the predictor-corrector method to solve this equation. \\
 As the first guess we take $\zeta_{n} \approx \zeta_{n-1/2} $, which means we have neglected the term $\zeta'_{n-1/2} d\tau/2 $, then we get the following equation,
 
      \begin{align}
  \zeta_{n+\frac{1}{2}} =&\zeta_{n-\frac{1}{2}} +  \Delta \tau \Bigg [3 \mathcal{H}_{n}(w\frac{\zeta_{n+\frac{1}{2}} + \zeta_{n-\frac{1}{2}} }{2} +c_s^2 \Psi_{n}) -c_s^2(   3 \mathcal{H}^2_{n} 
  - 3 \mathcal{H}' _{n}) \pi_{n}+ 3 c_s^2 \Phi'_{n}  +c_s^2 \nabla^2 \pi_{n} 
    \nonumber \\ &
  % Second order terms
     +2 c_s^2  \Phi_{n}  {\nabla^2 \pi_{n} }  
  %//////////////// 
  -   (1-c_s^2)  \Psi_{n} {\nabla^2 \pi_{n}}
  %////////////////
  -3 c_s^2 \mathcal{H}_{n} (1+w)\pi_{n} {\nabla^2 \pi_{n} }
      %////////////////
        +  (1-c_s^2)  { \Big( \frac{\zeta_{n+1/2} + \zeta_{n-1/2} }{2}+ \Psi_{n} \Big) } \nabla^2 {\pi_{n} }
                       \nonumber
   \\
    &
    %//////////////// 
             -c_s^2 {\nabla  \Phi_{n} . \nabla \pi_{n}}
   %//////////////// 
        +(2 c_s^2-1) {\nabla  \Psi_{n} . \nabla \pi_{n} }  
   %//////////////// 
 -\frac{\mathcal{H}_{n}} {2 } \Big(2+3w+c_s^2  \Big){\nabla  \pi_{n} . \nabla \pi_{n}} 
    %//////////////// 
    \nonumber \\ &
     +2   (1-c_s^2){\nabla  \pi_{n} . {  \nabla {  \Big(\ { \zeta_{n-1/2} }+ \Psi_{n} \Big)   }}}    \Bigg]
    \end{align}

    %%%%%%%%%%%%%%
    %%%%%%%%%%%%%%
    %%%%%%%%%%%%%%
    Factorizing $\zeta_{n+1/2}$ gives,
     \begin{align}
  \zeta_{n+\frac{1}{2}} & \Big[ 1-   3 \mathcal{H}_{n}  w   \Delta \tau   /2   - (1-c_s^2)   \nabla^2 {\pi_{n} }   \Delta \tau   /2 \Big] =\zeta_{n-\frac{1}{2}} +  \Delta \tau \Bigg [   3 \mathcal{H}_{n} ( w \frac{\zeta_{n-\frac{1}{2}}}{2} +c_s^2 \Psi_{n}) -c_s^2(   3 \mathcal{H}^2_{n} 
  - 3 \mathcal{H}' _{n}) \pi_{n}+ 3 c_s^2 \Phi'_{n}  
      \nonumber \\ &
+c_s^2 \nabla^2 \pi_{n} 
  % Second order terms
     +2 c_s^2  \Phi_{n}  {\nabla^2 \pi_{n} }  
  %//////////////// 
  -   (1-c_s^2)  \Psi_{n} {\nabla^2 \pi_{n}}
  %////////////////
  -3 c_s^2 \mathcal{H}_{n} (1+w)\pi_{n} {\nabla^2 \pi_{n} }
      %////////////////
        +  (1-c_s^2)  { \Big( \frac{\zeta_{n-1/2} }{2}+ \Psi_{n} \Big) } \nabla^2 {\pi_{n} }
                       \nonumber
   \\
    &
    %//////////////// 
             -c_s^2 {\nabla  \Phi_{n} . \nabla \pi_{n}}
   %//////////////// 
        +(2 c_s^2-1) {\nabla  \Psi_{n} . \nabla \pi_{n} }  
   %//////////////// 
 -\frac{\mathcal{H}_{n}} {2 } \Big(2+3w+c_s^2  \Big){\nabla  \pi_{n} . \nabla \pi_{n}} 
    %//////////////// 
    \nonumber \\ &
     +2   (1-c_s^2)\nabla  \pi_{n} . {  \nabla {  \Big({\zeta_{n-1/2} + \Psi_{n} \Big)   } }}    \Bigg]
    \end{align}
    Finally we can write the below equation,
      \begin{align}
  \zeta_{n+\frac{1}{2}} &  =\frac{1}{1-   3 \mathcal{H}_{n}  w   \Delta \tau   /2   - (1-c_s^2)   \nabla^2 {\pi_{n} }   \Delta \tau   /2 }  \Bigg[ \zeta_{n-\frac{1}{2}} +  \Delta \tau \Bigg (   3 \mathcal{H}_{n} ( w \frac{\zeta_{n-\frac{1}{2}}}{2} +c_s^2 \Psi_{n}) -c_s^2(   3 \mathcal{H}^2_{n} 
  - 3 \mathcal{H}' _{n}) \pi_{n}+ 3 c_s^2 \Phi'_{n}  
      \nonumber \\ &
+c_s^2 \nabla^2 \pi_{n} 
  % Second order terms
     +2 c_s^2  \Phi_{n}  {\nabla^2 \pi_{n} }  
  %//////////////// 
  -   (1-c_s^2)  \Psi_{n} {\nabla^2 \pi_{n}}
  %////////////////
  -3 c_s^2 \mathcal{H}_{n} (1+w)\pi_{n} {\nabla^2 \pi_{n} }
      %////////////////
        +  (1-c_s^2)  { \Big( \frac{\zeta_{n-1/2} }{2}+ \Psi_{n} \Big) } \nabla^2 {\pi_{n} }
                       \nonumber
   \\
    &
    %//////////////// 
             -c_s^2 {\nabla  \Phi_{n} . \nabla \pi_{n}}
   %//////////////// 
        +(2 c_s^2-1) {\nabla  \Psi_{n} . \nabla \pi_{n} }  
   %//////////////// 
 -\frac{\mathcal{H}_{n}} {2 } \Big(2+3w+c_s^2  \Big){\nabla  \pi_{n} . \nabla \pi_{n}} 
    %//////////////// 
    \nonumber \\ & 
     +2   (1-c_s^2)\nabla  \pi_{n} . {  \nabla {  \big({\zeta_{n-1/2} + \Psi_{n} \big)   } }}    \Bigg)   \Bigg]
    \end{align}
      which at linear order we get the same equation as we had before,
  \be
   \zeta_{n+\frac{1}{2}}= \frac{1}{1-  3   \mathcal{H}_{n} w \Delta \tau/2 } \Bigg[ \zeta_{n-\frac{1}{2}} +  \Delta \tau \Bigg( 3 \mathcal{H}_{n}\Big( \frac{ w\zeta_{n+\frac{1}{2}} }{2} +c_s^2 \Psi_{n} \Big)  -c_s^2(   3 \mathcal{H}^2_{n} 
  - 3 \mathcal{H}' _{n}) \pi_{n}+ 3 c_s^2 \Phi'_{n}  +c_s^2 \nabla^2 \pi_{n} \Bigg) \Bigg]
  \ee
It is very important to check everything for the first loop specifically! For the first loop we first compute $\zeta^{(-1/2)}$ by $\zeta_{-1/2} = \zeta_0 - \zeta'_{0} d\tau/2$  and then $\zeta$ is updated to have $\zeta^{(1/2)}$ from the values of $\Psi^{(0)}$ but we take $\Phi'^{(0)}=0$ which is an approximation in our scheme.\\
Then we go through the procedure which is the same for all loops (first loop included), which we update $\pi$ to have it at step 1 from the $\zeta_{1/2}$, during all of these procedures, $\Phi$ is assumed to be constant and we use $\Phi^{(1/2)}= \Phi^{(0)}$ since in the first loop $\Phi'$ is zero! So this is an approximation that in the first loop we take $\Psi'=0 $ and use the same $\Phi$ at 1/2 and 0 step the same. But in the other loops everything seems correct as following,\\
To compute $\zeta_{-1/2}$ we just use the linear equation for $\zeta'_{0}$ and also neglect $\Phi'_0$.\\
The whole updating loop is as following,\\
%{\color{red}NOTE!   \\
%%\be
%%\zeta^{n+1/2}, \zeta^{n}, \pi^{n},  \Psi^{n},  \Psi'^{n}   \longrightarrow  a_{kess}^{n+1/2}, \Psi^{n+1/2}, \zeta^{n+1/2},  \pi^{n+1}  \longrightarrow a_{kess}^{n+1},\pi^{n+1}, \Psi^{n+1},     \zeta^{n+3/2}.  
%%\ee
%Another way to update the fields is like velocities and positions and to compute $\zeta(n+1/2)$ just from $\zeta(n-1/2)$ and then compute $\zeta'(n)$, $\zeta'(n+1/2)$ and then extrapolate to compute $\zeta(n+1)$.}
\\
Note that here we can, not assign any $\zeta$ in integer steps, since we think it is not necessary, but if we want to calculate it we need to define a new field $\zeta_{int}$ which lives on the integer steps and is obtained by 
\be
\zeta_{int} (n+1) = \zeta_{n+1/2} + \zeta'_{int} d\tau/2
\ee
Where $\zeta'_{int}$ contains $ \zeta_{int}$ which comes from the corrected value of $ \zeta_{int}$. \\
	  \paragraph{Predictor-corrector method}
	We need this method only when we do not the values of the field at $\zeta(n)$ and we guess $\nabla \zeta(n)$ by   $\nabla \zeta(n-1/2)$ and then we correct it! This is something that can be corrected, but when we are assigning the $\zeta(n)$ by previous loop $\zeta(n) = \zeta_{n-1/2} + \zeta'_{n-1} d\tau $, so we have it and we do not need any corrector method! \\
This is an important part which should be done to have the errors propagation under the control. As we have explained already in the first loop of updating we take $\nabla \zeta_{n} = \nabla \zeta_{n-1/2}$ which is just prediction and then we calculate $\zeta_{n+1/2}$ from the predictor. So at the end we have $\zeta_{n+1/2}$ which we did not have in the begining, so we are going to use $ \zeta_{n+1/2}$ as new value to compute $\zeta_{n}$ by taking the average between the two and then again we calculate new corrected $\zeta_{n}$ and we take it as initial value to compute the corrected $\zeta_{n+1/2}$.\\
{\color{red} This one really does not work! Since we are using the value of $\zeta_{n}$, if we just use $\nabla \zeta_{n+1/2}$ and then we update it by the differential equation, it works well. At the end since we are using $\zeta_{int}$}
 \\ Moreover at the same time from the values of $\zeta_n$ and $\zeta'_n$ we compute $\zeta_{n+1}$ to be synched with particles and ... Although it may not improve very much or the stress tensor is not sensitive to this, but still we need to define such a filed at integer steps because of predictor-corrector method, so why not we compute $\zeta_{n+1}$ too! \\
The best way to do it is first to check that $\zeta_{n+1/2}$ from the next order corrector is  near to original one (like the relative error $2\frac{\zeta_1-\zeta_2}{\zeta_1+\zeta_2}<0.01$, which gives less than 1$\%$ error).\\
The important point is that, if we want to solve it systematically we really need to define $\zeta_{int}$ which is the integer $\zeta$, because at the end we want to compute $ \nabla \zeta_{n}$ which is only possible when we define $\zeta$ at integer steps, otherwise we do not have access to the $\zeta_{n} (x+1)$ or we must define 6 variables for it, $\zeta_{n} (x+0)$,  $\zeta_{n} (x+1)$... We prefer to define a new field $\zeta$ which lives in integer steps because it has the advantage of having it at step (n+1) which is synchronized with the $\pi$.\\
To summerize the predictor-corrector method.
\begin{itemize}
\item Calculating $\zeta_{n+1/2}$ from predictor $\nabla \zeta_{n-1/2}$\\
\item using new $\zeta_{n+1/2}$ and $\zeta_{n-1/2}$ to calculate $\zeta_{int}(n)$ by taking average and again calculate $\nabla \zeta_{n}$ and calculate new $ \zeta_{n+1/2}$ \\
. \\
. \\
\item continue to get the precise enough results \\
\item at the end from the last values at step n compute $\zeta'_n$ and from last $\zeta_{n+1/2}$, compute $\zeta_{n+1}$ and save as $\zeta_{int}$.

\end{itemize}


{{\color{Blue}Approximations:}}\\
{\color{red} The important approximations here are:\\
1- At the first loop we take $\Phi'=0$\\
2- To compute $\zeta_{-1/2}$ we neglect non-linear terms, but it should not be important, since we use predictor corrector method in other loops, which correct the values. \\
4- All the top approximations can be suppressed by increasing the number of kessence update or decreasing the time stepping of Gevolution.\\
5- We use predictor-corrector method for couple of times in each loop to correct our bad guess of non-linear term $\nabla \zeta_{n}$\\
}
\subsubsection{The loop}
\begin{itemize}
\item First we provide the initial condition for $\zeta(0)$, $\pi(0)$, $\Psi(0)$ \\
\item Then we update $\zeta$ by minus half step from the values at step 0 to get $\zeta(-1/2)$, just at the first loop!\\
\item So we are ready to go over the general loop, we first update $\zeta$ to have the value at $\zeta(1/2)$ from $\zeta(-1/2)$ and $\Phi(0)$, $\pi(0)$ , we compute $\zeta(1) = \zeta(1/2) + \zeta'(0) * d\tau$.\\
\item we compute $\zeta_1$ from the corrected values and by $\zeta_1 = \zeta_{1/2} + \zeta'_0$ \\
\item Then we compute $\pi(1)$, from $\pi(0)$ and $\zeta'(1/2)$, $\Phi'(1/2)$ and $\Phi(1/2)$,
\end{itemize}
So in general, we have,
\begin{itemize}
\item First we compute $\zeta_{n+1/2} =\zeta_{n-1/2} + \zeta'(n) $, where in $\zeta'(n)$ we have everything at step n which we know the values! \\
 \be
  \zeta_{n+\frac{1}{2}}=\zeta_{n} + \zeta'_{n} \Delta \tau \label{eqzeta}
  \ee
   $ \zeta'_{n}$ in the equation \ref{eqzeta} reads from the differential equation as following,
  \begin{align}
  \zeta'_{n} &= 3 \mathcal{H}_{n}(w \zeta_{n} +c_s^2 \Psi_{n}) -c_s^2(   3 \mathcal{H}^2_{n} 
  - 3 \mathcal{H}' _{n}) \pi_{n}+ 3 c_s^2 \Phi'_{n}  +c_s^2 \nabla^2 \pi_{n} \\ \nonumber &
   % Second order terms
     +2 c_s^2  \Phi_{n}  {\nabla^2 \pi_{n} }  
  %//////////////// 
  -   (1-c_s^2)  \Psi_{n} {\nabla^2 \pi_{n}}
  %////////////////
  -3 c_s^2 \mathcal{H}_{n} (1+w)\pi_{n} {\nabla^2 \pi_{n} }
      %////////////////
        +  (1-c_s^2)  { (\zeta_{n} + \Psi_{n}) } \nabla^2 {\pi_{n} }
                                       \nonumber
   \\
    &
    %//////////////// 
             -c_s^2 {\nabla  \Phi_{n} . \nabla \pi_{n}}
   %//////////////// 
        +(2 c_s^2-1) {\nabla  \Psi_{n} . \nabla \pi_{n} }  
   %//////////////// 
 -\frac{\mathcal{H}_{n}} {2 } \Big(2+3w+c_s^2  \Big){\nabla  \pi_{n} . \nabla \pi_{n}} 
    %//////////////// 
     +2   (1-c_s^2){\nabla  \pi_{n} . {  \nabla {  (\zeta_{n} + \Psi_{n})   }}}   
    \end{align}
    Where we only need $\Phi(n)$, $\Phi'(n)$, $\pi(n)$, $\zeta(n) = \frac{\zeta(n-1/2) +\zeta(n+1/2)  }{2}$. We have all the quantities simply at step n, so we do not need any extrapolation and etc. \\
    So by $\zeta(n) = \frac{\zeta(n-1/2) +\zeta(n+1/2)  }{2}$ we again can factorize and for the $\nabla ( \frac{\zeta_{(n-1/2)} +\zeta_{(n+1/2)}  }{2})$ which cannot be factorized we again use predictor-corrector method by guessing in the first loop that it is simply $\nabla  \zeta_{(n-1/2) /2}$, or it is better to use the values of $\zeta$ at integer steps, which is approximately correct but we can make it better by predictor-corrector method. \\
    
  \item Then we compute $\zeta(n+1)$ which is synchronized with everything by $\zeta(n+1) = \zeta(n) + \zeta'(n) d\tau$, we have defined two fields one is $\zeta_{int}$ and  the other $\zeta_{half}$. But note that it is better to update it by $\zeta_{n+1} = \zeta_{n+1/2} + \zeta'_{n+1/2} d \tau/2$, but in this case we need to have $\Phi'(n+1/2) = \frac{\Phi(n+1) - \Phi(n)}{d \tau}$ and of course we need $\Phi(n+1)$ which we don't have access to.\\
  
  \item Background is updated, $a_{kess}(n+1/2)$ since we need it for updating $\pi$. \\
\item After updating $\zeta(n+1/2)$, we update $\pi$ from n to n+1 as following,
\be
      \pi_{n+1}=\pi_{n} + \pi'_{n+\frac{1}{2}} \Delta \tau
    \ee
     \be
  \pi'_{n+\frac{1}{2}}=\zeta_{n+\frac{1}{2}}  -\mathcal{H}_{n+\frac{1}{2}}  \pi_{n+\frac{1}{2}}  +\Psi_{n+\frac{1}{2}} 
      \ee
      According to the definition, since the equation for updating $\pi$ is linear we do not have any trouble with non-linear terms and this part is done like linear equations.\\
      The background part  is better to be updated  before this step to have $a_{kess}$ at (n+1/2) and then having $\mathcal{H}(n+1/2)$. 
      Just note that making $\zeta$ updating at half steps help us because we need all the terms in $\zeta'(n)$ at integer steps. \\
      Since the scalar field Stress energy tensor must be synchronized with particles stress tensor, we need to have all the variables at the same step which is $n$, so we need to write all the terms at step ${n+\frac{1}{2}} $ in terms of the values at step $n$ and $n+1$ as following, of course except $\zeta$ which we have it at $n+1/2$. The easiest model to calculate $F_{{n+\frac{1}{2}} }$ is by taking average of the next and last step, so
     \be
     \pi_{n+\frac{1}{2}} = \frac{ \pi_{n+1} + \pi_{n} }{2 }
     \ee
     and the same for all the other variables at step ${n+\frac{1}{2}}$. 
   
     For $\pi$ we have,
         \be
      \pi_{n+1}=  \frac{1}{1+ \mathcal{H}_{n+\frac{1}{2}} \Delta \tau/2}\Bigg[ \pi_{n} + \Delta \tau \Big [  \zeta_{n+\frac{1}{2}}   -\mathcal{H}_{n+\frac{1}{2}}   \frac{  \pi_{n} }{2 } +\Psi_{n+\frac{1}{2}}  \Big ] \Bigg]
     \ee
   As it is clear from the formula we don't have access to the $\Psi_{n+\frac{1}{2}} $ and $\Psi_{n+1} $  , so we use the extrapolation  to have them in next half steps,
   \begin{align}
      \Psi_{n+\frac{1}{2}} = \Psi_{n} + \Psi'_{n} \frac{d \tau}{2} 
   \end{align} 
   Moreover to have $\Psi'_{n}$ we  use the following formula by saving $\Psi$ at two different steps!
   \be
   \Psi'_{n} = \frac{\Psi_{n} - \Psi_{n-1} }{d \tau}
   \ee
As it is clear we do not have any trouble with $\pi$ updating too, while in previous version of updating we were updating wrongly and $\zeta$ was ahead of potentials and we were using the wrong value for potentials.\\
\item One point: since we are using $\zeta_{int}$ so we have the value of $\zeta$ at step (n), so we basically we do not need the predictor-corrector method since we have  what we want, but we have this code for predictor method just to make sure that the approximation by taking the average is good enough, otherwise we need to go over loop for some time to reach our desired precision.\\
\item We turned off the corrector part, since we are doing everything clearly without any approximation in the non-linear part, so we do not need corrector method.  \\
\item At the end we need to test if out approximations work well? which is done in the next chapters by comparing the results versus mathematica and class.
\end{itemize}
\subsection{Gevolution code}
For the $\pi$ update we have linear equation and the code part is straightforward,
\begin{lstlisting}[language=C++,
  basicstyle=\tiny]
	template <class FieldType>
			void update_pi_k( double dtau, double dx,double a, Field<FieldType> & phi, Field<FieldType> & phi_old, Field<FieldType> & chi,Field<FieldType> & chi_old, Field<FieldType> & pi_k , Field<FieldType> & zeta_integer, Field<FieldType> & zeta_half, double Omega_fld ,double w, double cs2, double Hcon, double  H_prime, int non_linearity)
			{

        double psi, psi_prime, psi_half;
        double Coeff1 = 1./(1. + Hcon * dtau/2.);
			  Site x(phi.lattice());
			  for (x.first(); x.test(); x.next())
			    {
            psi=phi(x) - chi(x); //psi(n)
            psi_prime= ((phi(x) - chi(x)) - (phi_old(x) - chi_old(x))) / dtau; //psi'(n)
            psi_half= psi + psi_prime * dtau/2.; //psi_half (n+1/2) = psi(n) + psi_prime'(n) dtau/2
            //*****************************************
            //pi Updating which is linear by definition
            //*****************************************
            pi_k(x) = Coeff1 * ( pi_k(x)  + dtau * ( zeta_half(x) - Hcon * pi_k(x)/2. + psi_half ) ); //  pi_k(n+1)
            //*************************************************************************************
			    }
			}
\end{lstlisting}
For the stress tensor part we add the following part to the Gevolution.hpp,
\begin{lstlisting}[language=C++,
  basicstyle=\tiny]
			}
			template <class FieldType>
void projection_Tmunu_kessence( Field<FieldType> & T00, Field<FieldType> & T0i, Field<FieldType> & Tij,
   double dx, double a, Field<FieldType> & phi,Field<FieldType> & phi_old, Field<FieldType> & chi, Field<FieldType> & pi_k, Field<FieldType> & zeta_integer, double Omega_fld , double w, double cs2, double Hcon, double fourpig, int non_linearity ,int method )
{
    Site xField(phi.lattice());
    double coeff1, coeff2, coeff3, Hdot, psi;
    double gradientpi_squared, Dx_pi_Dx_pi, Dx_pi_Dy_pi, Dx_pi_Dz_pi, Dy_pi_Dy_pi, Dy_pi_Dz_pi, Dz_pi_Dz_pi;
    Site x(phi.lattice());
    double gradient_pi2;
    coeff1= Omega_fld * pow(a , -3. * w) * (1. + w) / (cs2);
    coeff2= Omega_fld * pow(a , -3. * w) * (1. + w);
    //*************************************************************
    //All non-linear terms are zero, except we have non-linearities
    //*************************************************************
    gradientpi_squared=0;
    Dx_pi_Dx_pi=0;
    Dx_pi_Dy_pi=0;
    Dx_pi_Dz_pi=0;
    Dy_pi_Dy_pi=0;
    Dy_pi_Dz_pi=0;
    Dz_pi_Dz_pi=0;
    for (xField.first(); xField.test(); xField.next())
      {
        if (non_linearity ==1)
          {
          //***************
          //(D_i pi)^2
          //***************
          gradientpi_squared =0.25*(pi_k(xField+0) - pi_k(xField - 0))* (pi_k(xField + 0) - pi_k(xField-0))/(dx*dx);
          gradientpi_squared+=0.25*(pi_k(xField+1) - pi_k(xField - 1))* (pi_k(xField + 1) - pi_k(xField-1))/(dx*dx);
          gradientpi_squared+=0.25*(pi_k(xField+2) - pi_k(xField - 2))* (pi_k(xField + 2) - pi_k(xField-2))/(dx*dx);
          //***************
          //(X,X):::::::> Dx_pi_Dx_pi = GradX(pi).GradX(pi)
          //***************
          Dx_pi_Dx_pi =0.25*(pi_k(xField+0) - pi_k(xField-0))* (pi_k(xField+0) - pi_k(xField-0))/(dx*dx);
          //***************
          //(X,Y):::::::> Dx_pi_Dy_pi = GradX(pi).GradY(pi) = GradY(pi).GradX(pi)
          //***************
          Dx_pi_Dy_pi =0.25*(pi_k(xField+0) - pi_k(xField-0))* (pi_k(xField+1) - pi_k(xField-1))/(dx*dx);
          //***************
          //(X,Z):::::::> Dx_pi_Dz_pi = GradX(pi).GradZ(pi)
          //***************
          Dx_pi_Dz_pi =0.25*(pi_k(xField+0) - pi_k(xField-0))* (pi_k(xField+2) - pi_k(xField-2))/(dx*dx);
          //***************
          //(Y,Y):::::::> Dy_pi_Dy_pi = GradY(pi).GradY(pi)
          //***************
          Dy_pi_Dy_pi =0.25*(pi_k(xField+1) - pi_k(xField-1))* (pi_k(xField+1) - pi_k(xField-1))/(dx*dx);
          //***************
          //(Y,Z):::::::> Dy_pi_Dz_pi = Grady(pi).Gradz(pi)
          //***************
          Dy_pi_Dz_pi =0.25*(pi_k(xField+1) - pi_k(xField-1))* (pi_k(xField+2) - pi_k(xField-2))/(dx*dx);
          //***************
          //(Z,Z):::::::> Dz_pi_Dz_pi = Gradz(pi).Gradz(pi)
          //***************
          Dz_pi_Dz_pi =0.25*(pi_k(xField+2) - pi_k(xField-2))* (pi_k(xField+2) - pi_k(xField-2))/(dx*dx);
          }
        //***************
        psi= phi(xField) - chi(xField);
        //************************
        //STRESS TENSOR COMPONENTS
        //************************
        // 0-0-component: (Time,Time)
        T00(xField)       = - coeff1 * ( -3. * cs2 * Hcon * pi_k(xField) + zeta_integer(xField)
                          /*Non-linear*/ -  non_linearity * (1. - 2. * cs2) * gradientpi_squared / 2.  );
        //*************************************************************************************
        // 1-1-component: (X,X)
        Tij(xField, 0, 0) = + coeff2 * (-3.* w * Hcon* pi_k(xField) + zeta_integer(xField)
                          /*Non-linear*/ - non_linearity * (gradientpi_squared / 2.  + Dx_pi_Dx_pi) );
        //*************************************************************************************
        // 2-2-component: (Y,Y)
        Tij(xField, 1, 1) = + coeff2 * (-3.* w * Hcon* pi_k(xField) +   zeta_integer(xField)
                          /*Non-linear*/ -  non_linearity * (gradientpi_squared / 2.  + Dy_pi_Dy_pi) );
        //*************************************************************************************
        // 3-3-component: (Z,Z)
        Tij(xField, 2, 2) = + coeff2 * (-3.* w * Hcon* pi_k(xField) +   zeta_integer(xField)
                          /*Non-linear*/ -  non_linearity * (gradientpi_squared / 2.  + Dz_pi_Dz_pi) );
        //*************************************************************************************
        // 1-2-component: (X,Y)
        Tij(xField, 0, 1) = + non_linearity *  coeff2 * (/*Non-linear*/ Dx_pi_Dy_pi);
        //*************************************************************************************
        // 1-3-component: (X,Z)
        Tij(xField, 0, 2) = + non_linearity *  coeff2 * (/*Non-linear*/ Dx_pi_Dz_pi);
        //*************************************************************************************
        // 2-3-component: (Y,Z)
        Tij(xField, 1, 2) = + non_linearity *  coeff2 * (/*Non-linear*/ Dy_pi_Dz_pi);
        //*************************************************************************************

        //*******************************
        //In the case of Vector parabolic
        //*******************************
        if(method==1) // method=1 Turn on vector elliptic
        {
          if (non_linearity ==1)
            {
					// T01:(Time,X)
            T0i(xField, 0)  =  -coeff2 * (1. - /*Non-linear*/  non_linearity * (1./cs2 -1.) * gradientpi_squared / 2.) *       (pi_k(xField + 0) - pi_k(xField - 0)) / (2. * dx);
            //*************************************************************************************
  					// T02:(Time,Y)
            T0i(xField, 1)  =  -coeff2 *  (1. - /*Non-linear*/  non_linearity * (1./cs2 -1.) * gradientpi_squared / 2.) *       (pi_k(xField + 1) - pi_k(xField - 1)) / (2. * dx);
            //*************************************************************************************
            // T03:(Time,Z)
            T0i(xField, 2)  =  -coeff2 *  (1. - /*Non-linear*/  non_linearity * (1./cs2 -1.) * gradientpi_squared / 2.) *       (pi_k(xField + 2) - pi_k(xField - 2)) / (2. * dx);
            //*************************************************************************************
          }
        }
      }
    }
\end{lstlisting}
For the $\zeta$ update, we have turned off the predictor-corrector part, we have
\begin{lstlisting}[language=C++,
  basicstyle=\tiny]
  	template <class FieldType>
			void update_zeta(double dtau, double dx,double a, Field<FieldType> & phi, Field<FieldType> & phi_old, Field<FieldType> & chi,Field<FieldType> & chi_old, Field<FieldType> & pi_k , Field<FieldType> & zeta_integer, Field<FieldType> & zeta_half, double Omega_fld ,double w, double cs2, double Hcon, double H_prime, int non_linearity )
			  {
        double Gradphi_Gradpi, Gradpsi_Gradpi, Gradpi_Gradpi, GradPsiZeta_Gradpi, Dx_psi, Dy_psi, Dz_psi;
			  double C1, C2, C3, psi, psi_old, psi_prime, phi_prime, Laplacian_pi, zeta_old_half, zeta_old_integer;
        //Since a_kess is at n so H_prime is at n which is needed to calculate zeta(n+1/2)
        //**************************************************************
        //Coefficient two, H(n), H_prime(n) since BG already updated
        //**************************************************************
        C2 = cs2 * (3. * Hcon * Hcon - 3. * H_prime );
        //**************************************************************
        //Coefficient three, H(n), H_prime(n)
        //**************************************************************
        C3 = (2. + 3. * w + cs2 ) *  Hcon/2.;

        //**************************************************************
        //When non-linearities are turned off we put non-linear temrs zero
        //**************************************************************
        Gradphi_Gradpi=0.;
        Gradpsi_Gradpi=0.;
        Gradpi_Gradpi=0.;
        GradPsiZeta_Gradpi=0.;
				Site x(phi.lattice());
				for (x.first(); x.test(); x.next())
					{
          //****************************************************************
          //Laplace pi, pi(n) since pi is not updated yet
          //****************************************************************
					Laplacian_pi= pi_k(x-0) + pi_k(x+0) - 2. * pi_k(x);
					Laplacian_pi+=pi_k(x+1) + pi_k(x-1) - 2. * pi_k(x);
					Laplacian_pi+=pi_k(x+2) + pi_k(x-2) - 2. * pi_k(x);
          Laplacian_pi= Laplacian_pi/(dx*dx);
          //********************************************
          //psi(n)
          //*********************************************
					psi = phi(x) - chi(x);
          //***************************
          //Coefficient one, H( at n)
          //***************************
          C1 = 1./(1. -  3. * Hcon * w  * dtau/2. -  non_linearity * (1. - cs2) *  Laplacian_pi * dtau/2.);
          //**********************************************
          //phi'(n)
          //**********************************************
				  phi_prime= (phi(x) - phi_old(x))/dtau; //phi_prime(n) since we want to use it to compute zeta (n+1/2)
          //********************************
          //psi'(n)
          //psi(n)
          //********************************
          psi_prime= ((phi(x) - chi(x)) - (phi_old(x) - chi_old(x)))/dtau;
          if (non_linearity ==1)
            {
            //**********
            //Grad_i Psi
            //**********
            Dx_psi = ((phi(x + 0) - chi(x + 0)) - (phi(x - 0) - chi(x - 0)));
            Dy_psi = ((phi(x + 1) - chi(x + 1)) - (phi(x - 1) - chi(x - 1)));
            Dz_psi = ((phi(x + 2) - chi(x + 2)) - (phi(x - 2) - chi(x - 2)));
            //*******************
            //Grad_phi . Grad_pi
            //******************
            Gradphi_Gradpi= 0.25 * (phi(x + 0)  - phi(x - 0)) * (pi_k(x + 0) - pi_k(x - 0)) / (dx * dx);
            Gradphi_Gradpi+=0.25 * (phi(x + 1)  - phi(x - 1)) * (pi_k(x + 1) - pi_k(x - 1)) / (dx * dx);
            Gradphi_Gradpi+=0.25 * (phi(x + 2)  - phi(x - 2)) * (pi_k(x + 2) - pi_k(x - 2)) / (dx * dx);
            //*******************
            //Grad_psi . Grad_pi
            //******************
            Gradpsi_Gradpi= 0.25 * (Dx_psi) * (pi_k(x+0) - pi_k(x-0)) / (dx * dx);
    			  Gradpsi_Gradpi+=0.25 * (Dy_psi) * (pi_k(x+1) - pi_k(x-1)) / (dx * dx);
    			  Gradpsi_Gradpi+=0.25 * (Dz_psi) * (pi_k(x+2) - pi_k(x-2)) / (dx * dx);
            //*************
            //Gradpi_Gradpi
            //*************
            Gradpi_Gradpi= 0.25 * (pi_k(x + 0)  - pi_k(x - 0)) * (pi_k(x + 0) - pi_k(x - 0)) / (dx * dx);
            Gradpi_Gradpi+=0.25 * (pi_k(x + 1)  - pi_k(x - 1)) * (pi_k(x + 1) - pi_k(x - 1)) / (dx * dx);
            Gradpi_Gradpi+=0.25 * (pi_k(x + 2)  - pi_k(x - 2)) * (pi_k(x + 2) - pi_k(x - 2)) / (dx * dx);
            //*************************************************************
            //GradPsiZeta_Gradpi = Grad_pi . Grad_ (zeta + psi)
            //Grad_pi . Grad_ (zeta + psi) = Grad_pi (Grad_zeta + Grad_Psi)
            //zeta_integer from previous step is at n
            //*************************************************************
            GradPsiZeta_Gradpi= 0.25* (zeta_integer(x+0) - zeta_integer(x-0) + Dx_psi) * (pi_k(x+0) - pi_k(x-0)) / (dx * dx);
            GradPsiZeta_Gradpi+=0.25* (zeta_integer(x+1) - zeta_integer(x-1) + Dy_psi) * (pi_k(x+1) - pi_k(x-1)) / (dx * dx);
            GradPsiZeta_Gradpi+=0.25* (zeta_integer(x+2) - zeta_integer(x-2) + Dz_psi) * (pi_k(x+2) - pi_k(x-2)) / (dx * dx);
          }
          //***********************************
          // Having the values at previous steps
          //***********************************
          zeta_old_half = zeta_half(x); //zeta(n-1/2)
          //***********************
          // FULL Updating equation
          //***********************
          //***************************************
          // zeta(n+1/2) = zeta(n-1/2) + zeta'(n)
          //***************************************
          zeta_half(x) =         C1 * ( zeta_half(x) + dtau * (
          /*Linear(1,2,3)*/      + 3. * Hcon * ( w * zeta_half(x)/2. + cs2 * psi ) - C2 * pi_k(x)
          /*Linear(4,5)*/        + 3. * cs2 * phi_prime + cs2 * Laplacian_pi
          /*Non-linear terms*/   + non_linearity * (
          /*Non-linear(1,2)*/    + 2. * cs2 * phi(x) * Laplacian_pi- (1. - cs2) * psi * Laplacian_pi
          /*Non-linear(3)  */    - 3. * cs2 * Hcon * (1. + w) * pi_k(x) * Laplacian_pi
           /*Non-linear(5,6,7)*/  - cs2 * Gradphi_Gradpi + (2. * cs2 -1.) * Gradpsi_Gradpi - C3 * Gradpi_Gradpi
          /*Non-linear(8)  */    + 2. * (1. - cs2) * GradPsiZeta_Gradpi
                                                    )
                                                      )
                                      );
          //**********************************************************************
          //Computing zeta(n+1)
          //**********************************************************************
          double zeta_prime_int_n0 ;
          //**********************************************
          // zeta'(n) from the new values at n, zeta(n)...
          // like zeta_integer(x) (n)
          //**********************************************
          zeta_prime_int_n0 =
          /*Linear(1,2,3)*/      + 3. * Hcon * ( w * zeta_integer(x) + cs2 * psi ) - C2 * pi_k(x)
          /*Linear(4,5)*/        + 3. * cs2 * phi_prime + cs2 * Laplacian_pi
          /*Non-linear(1,2)*/    + 2. * cs2 * phi(x) * Laplacian_pi - (1. - cs2) * psi * Laplacian_pi
          /*Non-linear(3)  */    - 3. * cs2 * Hcon * (1. + w) * pi_k(x) * Laplacian_pi
          /*Non-linear(4)  */    +(1. - cs2) * (zeta_integer(x) + psi) * Laplacian_pi
          /*Non-linear(5,6,7)*/  - cs2 * Gradphi_Gradpi + (2. * cs2 -1.) * Gradpsi_Gradpi - C3 * Gradpi_Gradpi
          /*Non-linear(8)  */    + 2.* (1. - cs2) * GradPsiZeta_Gradpi;
        //***********************************************************************************
        // When we get the precision and it goes out of loop we need to update zeta_integer for
        //being synched with particles and ....
        //zeta(n+1) = zeta(n+1/2) + zeta'(n)dtau/2
        //***********************************************************************************
        zeta_integer(x) = zeta_half(x) +   zeta_prime_int_n0 * dtau/2.;

             }
      }
			}
\end{lstlisting}
In the main file we have stress tensor of kessence and main update of the fields
\begin{lstlisting}[language=C++,
  basicstyle=\tiny]
			}
			if (sim.Kess_source_gravity==1)
{
// Kessence projection Tmunu
// In the projection zeta_integer comes, since synched with particles..
 	if (sim.vector_flag == VECTOR_ELLIPTIC)
		{
			projection_Tmunu_kessence( T00_Kess,T0i_Kess,Tij_Kess, dx, a, phi, phi_old, 	chi, pi_k, zeta_integer, cosmo.Omega_kessence, cosmo.w_kessence, cosmo.cs2_kessence, Hconf(a, fourpiG, cosmo), fourpiG, sim.NL_kessence ,1 );
		}
 	else
		{
			projection_Tmunu_kessence( T00_Kess,T0i_Kess,Tij_Kess, dx, a, phi, phi_old, 	chi, pi_k, zeta_integer, cosmo.Omega_kessence, cosmo.w_kessence, cosmo.cs2_kessence, Hconf(a, fourpiG, cosmo), fourpiG, sim.NL_kessence, 0 );
		}

		for (x.first(); x.test(); x.next())
		{
			// The coefficient is because it wanted to to be source according to eq C.2 of Gevolution paper
			// Note that it is multiplied to dx^2 and is divived by -a^3 because of definition of T00 which is scaled by a^3
			// We have T00 and Tij according to code's units, but source is important to calculate potentials and moving particles.
			// There is coefficient between Tij and Sij as source.
			source(x) += (fourpiG * dx * dx / a) * T00_Kess(x);
			if (sim.vector_flag == VECTOR_ELLIPTIC)for(int 	c=0;c<3;c++)Bi(x,c)+= (2. * fourpiG * dx * dx / a) * T0i_Kess(x,c);
			for(int c=0;c<6;c++)Sij(x,c)+=(2. * fourpiG * dx * dx / a) * Tij_Kess(x,c);
		}
}
#ifdef BENCHMARK
		kessence_update_time += MPI_Wtime() - ref_time;
		ref_time = MPI_Wtime();
#endif
// Kessence projection Tmunu end

//Kessence
#ifdef BENCHMARK
		ref_time = MPI_Wtime();
#endif
        for (x.first(); x.test(); x.next())
    		{
    			phi_prime(x) =(phi(x)-phi_old(x))/(dtau);
    		}
        // We just need to update halo when we want to calculate spatial derivative or use some neibours at the same time! So here wo do not nee to update halo for phi_prime!
//**********************
//Kessence - LeapFrog:START
//**********************
  double a_kess=a;
	for (i=0;i<sim.nKe_numsteps;i++)
	{
    //First we update zeta_integer to have it at 0-1/2 just in the first loop
    if(cycle==0)
    {
      //computing zeta_half(-1/2) and zeta_int(-1) but we do not work with zeta(-1)
      update_zeta(-dtau/ (2. * sim.nKe_numsteps) , dx, a_kess, phi, phi_old, chi, chi_old, pi_k, zeta_integer, zeta_integer, cosmo.Omega_kessence, cosmo.w_kessence, cosmo.cs2_kessence, Hconf(a_kess, fourpiG, cosmo), Hconf_prime(a_kess, fourpiG, cosmo), sim.NL_kessence);
    }
    //********************************************************************************
    //Updating zeta_integer to get zeta_integer(n+1/2) and zeta_integer(n+1), in the first loop is getting zeta_integer(1/2) and zeta_integer(1)
    // In sum: zeta_integer(n+1/2) = zeta_integer(n-1/2)+ zeta_integer'(n)dtau which needs background to be at n with then
    //Note that here for zeta_integer'(n) we need background to be at n and no need to update it.
    //\zeta_integer(n+1/2) = \zeta_integer(n-1/2) + \zeta_integer'(n)  dtau
    //We also update zeta_int from n to n+1
    //********************************************************************************
    update_zeta(dtau/ sim.nKe_numsteps, dx, a_kess, phi, phi_old, chi, chi_old, pi_k, zeta_integer, zeta_integer, cosmo.Omega_kessence, cosmo.w_kessence, cosmo.cs2_kessence, Hconf(a_kess, fourpiG, cosmo), Hconf_prime(a_kess, fourpiG, cosmo), sim.NL_kessence);
    //********************************************************************************
    //Since we have pi(n+1)=pi(n) + pi'(n+1/2), and in pi'(n+1/2) we have H(n+1/2) we update the background before updating the pi to have H(n+1/2), Moreover zeta(n+1) = zeta(n+1/2) + zeta'(n+1/2), so we put zeta_int updating in the pi updating!
    //********************************************************************************
    rungekutta4bg(a_kess, fourpiG, cosmo,  dtau  / sim.nKe_numsteps / 2.0);
    //********************************************************************************
    //we update pi to have it at n+1 (at first loop from the value at (0) and the value of zeta_integer at 1/2 and H(n+1/2) we update pi at (1))
    //In the pi update we also update zeta_int because we need the values of a_kess and H_kess at step n+1/2
    //By the below update we get pi(n+1) and zeta(n+1)
    //********************************************************************************
    update_pi_k(dtau/ sim.nKe_numsteps, dx, a_kess, phi, phi_old, chi, chi_old, pi_k, zeta_integer, zeta_integer, cosmo.Omega_kessence, cosmo.w_kessence, cosmo.cs2_kessence, Hconf(a_kess, fourpiG, cosmo), Hconf_prime(a_kess, fourpiG, cosmo), sim.NL_kessence); // H_old is updated here in the function
		pi_k.updateHalo();
    zeta_integer.updateHalo();
    //********************************************************************************
    // Now we have pi(n+1) and a_kess(n+1/2) so we update background by halfstep to have a_kess(n+1)
    //********************************************************************************
    rungekutta4bg(a_kess, fourpiG, cosmo,  dtau  / sim.nKe_numsteps / 2.0 );

	}
#ifdef BENCHMARK
    kessence_update_time += MPI_Wtime() - ref_time;
    ref_time = MPI_Wtime();
#endif
//**********************
//Kessence - LeapFrog: End
//**********************

\end{lstlisting}
\end{document}